# Data Modeling

- Name 3 advantages to Test Driven Development
    1. Better program design and higher code quality
    2. Detailed project documentation
    3. TDD reduces the time required for project development


- In what case would you need to use beforeEach() or afterEach() in a test suite?



- What is one downside of Test Driven Development
    **slow process**

If you begin TDD, you’ll get the sensation that you simply need an extended duration of your time for straightforward implementations. you would like to believe the interfaces, write the test code, and run the tests before you’ll finally start writing the code.

- What’s the primary difference between ES6 Classes and Constructor/Prototype Classes?

The most important difference between class- and prototype-based inheritance is that a class defines a type which can be instantiated at runtime, whereas a prototype is itself an object instance.

- Why REST?

    1. REST is Easy to Understand and Implement
    2. REST Makes your Application More Scalable




## SQL 


* SQL stands for Structured Query Language
* SQL lets you access and manipulate databases
* SQL became a standard of the American National Standards Institute (ANSI) in 1986, and of the International 
* Organization for Standardization (ISO) in 1987

![](https://milesbreedsolutions.com/wp-content/uploads/2018/04/SQL.jpg)

## noSQL

NoSQL databases are purpose built for specific data models and have flexible schemas for building modern applications. NoSQL databases are widely recognized for their ease of development, functionality, and performance at scale.

![](https://cdn.educba.com/academy/wp-content/uploads/2019/05/what-is-Nosql-database1.png)


## SQL vs noSQL

    The table below summarizes the main differences between SQL and NoSQL databases.

||SQL Databases|NoSQL Databases|
|--|--|--|
|Data Storage Model|Tables with fixed rows and columns|Document: JSON documents, Key-value: key-value pairs, Wide-column: tables with rows and dynamic columns, Graph: nodes and edges|
|Development History|Developed in the 1970s with a focus on reducing data duplication|Developed in the late 2000s with a focus on scaling and allowing for rapid application change driven by agile and DevOps practices.|
|Examples|Oracle, MySQL, Microsoft SQL Server, and PostgreSQL|Document: MongoDB and CouchDB, Key-value: Redis and DynamoDB, Wide-column: Cassandra and HBase, Graph: Neo4j and Amazon Neptune|
|Primary Purpose|General purpose|Document: general purpose, Key-value: large amounts of data with simple lookup queries, Wide-column: large amounts of data with predictable query patterns, Graph: analyzing and traversing relationships between connected data|
|Schemas|Rigid|Flexible|
|Scaling|Vertical (scale-up with a larger server)|Horizontal (scale-out across commodity servers)|
|Multi-Record ACID Transactions|Supported|Most do not support multi-record ACID transactions. However, some—like MongoDB—do.|
|Joins|Typically required|Typically not required|
|Data to Object Mapping|Requires ORM (object-relational mapping)|Many do not require ORMs. MongoDB documents map directly to data structures in most popular programming languages.|
